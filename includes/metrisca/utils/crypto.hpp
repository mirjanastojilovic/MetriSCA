/**
 * MetriSCA - A side-channel analysis library
 * Copyright 2021, School of Computer and Communication Sciences, EPFL.
 *
 * All rights reserved. Use of this source code is governed by a
 * BSD-style license that can be found in the LICENSE.md file.
 */

#ifndef _CRYPTO_HPP
#define _CRYPTO_HPP

#include <array>

namespace metrisca { namespace crypto {

    /// Perform the Rijndael S-box substitution on a byte
    static uint8_t SBox(uint8_t byte) 
    {
        static std::array<uint8_t, 256> sbox = 
            {0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
            ,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
            ,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
            ,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
            ,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
            ,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
            ,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
            ,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
            ,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
            ,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
            ,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
            ,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
            ,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
            ,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
            ,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
            ,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16};

        return sbox[byte];
    }

    /// Perform the inverse Rijndael S-box substitution on a byte
    static uint8_t SBoxInverse(uint8_t byte) 
    {
        static std::array<uint8_t, 256> sbox_inv =
            {0x52 ,0x09 ,0x6A ,0xD5 ,0x30 ,0x36 ,0xA5 ,0x38 ,0xBF ,0x40 ,0xA3 ,0x9E ,0x81 ,0xF3 ,0xD7 ,0xFB
            ,0x7C ,0xE3 ,0x39 ,0x82 ,0x9B ,0x2F ,0xFF ,0x87 ,0x34 ,0x8E ,0x43 ,0x44 ,0xC4 ,0xDE ,0xE9 ,0xCB
            ,0x54 ,0x7B ,0x94 ,0x32 ,0xA6 ,0xC2 ,0x23 ,0x3D ,0xEE ,0x4C ,0x95 ,0x0B ,0x42 ,0xFA ,0xC3 ,0x4E
            ,0x08 ,0x2E ,0xA1 ,0x66 ,0x28 ,0xD9 ,0x24 ,0xB2 ,0x76 ,0x5B ,0xA2 ,0x49 ,0x6D ,0x8B ,0xD1 ,0x25
            ,0x72 ,0xF8 ,0xF6 ,0x64 ,0x86 ,0x68 ,0x98 ,0x16 ,0xD4 ,0xA4 ,0x5C ,0xCC ,0x5D ,0x65 ,0xB6 ,0x92
            ,0x6C ,0x70 ,0x48 ,0x50 ,0xFD ,0xED ,0xB9 ,0xDA ,0x5E ,0x15 ,0x46 ,0x57 ,0xA7 ,0x8D ,0x9D ,0x84
            ,0x90 ,0xD8 ,0xAB ,0x00 ,0x8C ,0xBC ,0xD3 ,0x0A ,0xF7 ,0xE4 ,0x58 ,0x05 ,0xB8 ,0xB3 ,0x45 ,0x06
            ,0xD0 ,0x2C ,0x1E ,0x8F ,0xCA ,0x3F ,0x0F ,0x02 ,0xC1 ,0xAF ,0xBD ,0x03 ,0x01 ,0x13 ,0x8A ,0x6B
            ,0x3A ,0x91 ,0x11 ,0x41 ,0x4F ,0x67 ,0xDC ,0xEA ,0x97 ,0xF2 ,0xCF ,0xCE ,0xF0 ,0xB4 ,0xE6 ,0x73
            ,0x96 ,0xAC ,0x74 ,0x22 ,0xE7 ,0xAD ,0x35 ,0x85 ,0xE2 ,0xF9 ,0x37 ,0xE8 ,0x1C ,0x75 ,0xDF ,0x6E
            ,0x47 ,0xF1 ,0x1A ,0x71 ,0x1D ,0x29 ,0xC5 ,0x89 ,0x6F ,0xB7 ,0x62 ,0x0E ,0xAA ,0x18 ,0xBE ,0x1B
            ,0xFC ,0x56 ,0x3E ,0x4B ,0xC6 ,0xD2 ,0x79 ,0x20 ,0x9A ,0xDB ,0xC0 ,0xFE ,0x78 ,0xCD ,0x5A ,0xF4
            ,0x1F ,0xDD ,0xA8 ,0x33 ,0x88 ,0x07 ,0xC7 ,0x31 ,0xB1 ,0x12 ,0x10 ,0x59 ,0x27 ,0x80 ,0xEC ,0x5F
            ,0x60 ,0x51 ,0x7F ,0xA9 ,0x19 ,0xB5 ,0x4A ,0x0D ,0x2D ,0xE5 ,0x7A ,0x9F ,0x93 ,0xC9 ,0x9C ,0xEF
            ,0xA0 ,0xE0 ,0x3B ,0x4D ,0xAE ,0x2A ,0xF5 ,0xB0 ,0xC8 ,0xEB ,0xBB ,0x3C ,0x83 ,0x53 ,0x99 ,0x61
            ,0x17 ,0x2B ,0x04 ,0x7E ,0xBA ,0x77 ,0xD6 ,0x26 ,0xE1 ,0x69 ,0x14 ,0x63 ,0x55 ,0x21 ,0x0C ,0x7D};

        return sbox_inv[byte];
    }

    /// Get the round constant for a specific round of the key expansion algorithm
    static uint8_t RCon(uint8_t round) 
    {
        static std::array<uint8_t, 256> rcon = 
            {0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a 
            ,0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39 
            ,0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a 
            ,0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8 
            ,0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef 
            ,0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc 
            ,0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b 
            ,0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3 
            ,0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94 
            ,0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20 
            ,0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35 
            ,0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f 
            ,0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04 
            ,0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63 
            ,0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd 
            ,0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d};

        return rcon[round];
    }

    /// Perform multiplication by two in Rijndael's Galois field
    static uint8_t GMulByTwo(uint8_t byte) 
    {
        static std::array<uint8_t, 256> gl2 = 
            {0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e
            ,0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e
            ,0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e
            ,0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e
            ,0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e
            ,0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe
            ,0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde
            ,0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe
            ,0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05
            ,0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25
            ,0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45
            ,0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65
            ,0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85
            ,0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5
            ,0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5
            ,0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5};

        return gl2[byte];
    }

    /// Perform multiplication by three in Rijndael's Galois field
    static uint8_t GMulByThree(uint8_t byte) 
    {
        static std::array<uint8_t, 256> gl3 = 
            {0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11
            ,0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21
            ,0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71
            ,0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41
            ,0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1
            ,0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1
            ,0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1
            ,0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81
            ,0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a
            ,0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba
            ,0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea
            ,0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda
            ,0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a
            ,0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a
            ,0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a
            ,0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a};

        return gl3[byte];
    }

    /// Compute the hamming weight of a byte
    static uint8_t HammingWeight(uint8_t val) 
    {
        uint8_t weight = 0;
        while(val) {
            weight++;
            val &= val - 1;
        }
        return weight;
    }

    /// Compute the hamming distance of two bytes
    static uint8_t HammingDistance(uint8_t a, uint8_t b) 
    {
        return HammingWeight(a ^ b);
    }

    class sbox {
    public:

        /// Perform the S-BOX encryption of a plaintext using a key
        static uint8_t Encrypt(uint8_t plaintext, uint8_t key) 
        {
            return SBox(plaintext ^ key);
        }

    };

    class aes128 {
    public:

#define AES128_BLOCK_SIZE 16
#define AES128_ROUNDS 10

        static std::array<uint8_t, AES128_BLOCK_SIZE> Encrypt(const std::array<uint8_t, AES128_BLOCK_SIZE>& plaintext,
            const std::array<uint8_t, AES128_BLOCK_SIZE>& key)
        {
            return Encrypt(plaintext, ExpandKey(key));
        }

        static std::array<uint8_t, AES128_BLOCK_SIZE> Encrypt(const std::array<uint8_t, AES128_BLOCK_SIZE>& plaintext, 
            const std::vector<std::array<uint8_t, AES128_BLOCK_SIZE>>& expanded_key) 
        {
            std::array<uint8_t, AES128_BLOCK_SIZE> state;
            for(size_t i = 0; i < state.size(); ++i)
            {
                state[i] = plaintext[i];
            }

            //Initial round
            AddRoundKey(state, expanded_key[0]);

            //Encryption rounds
            for(uint8_t i = 1; i <= 9; i++)
            {
                SubBytes(state);
                ShiftRows(state);
                MixColumns(state);
                AddRoundKey(state, expanded_key[i]);
            }

            //Final round
            SubBytes(state);
            ShiftRows(state);
            AddRoundKey(state, expanded_key[10]);

            return state;
        }

        static std::vector<std::array<uint8_t, AES128_BLOCK_SIZE>> ExpandKey(const std::array<uint8_t, AES128_BLOCK_SIZE>& key)
        {
            std::vector<std::array<uint8_t, AES128_BLOCK_SIZE>> expandedKey(AES128_ROUNDS + 1);
            const uint32_t expandedSize = AES128_BLOCK_SIZE * (AES128_ROUNDS + 1);
            uint8_t expanded[expandedSize];

            // Copy the original key
            for(int i = 0; i < AES128_BLOCK_SIZE; i++)
            {
                expanded[i] = key[i];
            }

            uint32_t generatedBytes = 16;
            uint32_t rconIter = 1;
            std::array<uint8_t, 4> tmp;
            while(generatedBytes < expandedSize)
            {
                // Read last 4 generated bytes
                for(int i = 0; i < 4; i++)
                {
                    tmp[i] = expanded[i + generatedBytes - 4];
                }

                if(generatedBytes % 16 == 0)
                {
                    KeyExpansionCore(tmp, rconIter++);
                }

                for(int i = 0; i < 4; i++)
                {
                    expanded[generatedBytes] = expanded[generatedBytes - 16] ^ tmp[i];
                    generatedBytes++;
                }
            }

            for(int i = 0; i < AES128_ROUNDS + 1; i++)
            {
                for(int j = 0; j < AES128_BLOCK_SIZE; j++)
                {
                    expandedKey[i][j] = expanded[i * AES128_BLOCK_SIZE + j];
                }
            }
            return expandedKey;
        }

        static std::vector<std::array<uint8_t, AES128_BLOCK_SIZE>> ReverseKeySchedule(const std::array<uint8_t, AES128_BLOCK_SIZE>& last_round_key)
        {
            std::vector<std::array<uint8_t, AES128_BLOCK_SIZE>> expandedKey(AES128_ROUNDS + 1);
            const uint32_t expandedSize = 16 * (AES128_ROUNDS + 1);
            uint8_t expanded[expandedSize];

            //Copy the last round key
            for(int i = 0; i < 16; i++)
            {
                expanded[i + 160] = last_round_key[i];
            }

            uint32_t generatedBytes = 16;
            uint32_t rconIter = 10;
            std::array<uint8_t, 4> tmp;
            while(generatedBytes < expandedSize)
            {
                // Read last 4 generated bytes
                for(int i = 0; i < 4; i++)
                {
                    tmp[i] = expanded[expandedSize - generatedBytes + 16 - 8 + i];
                }

                if(generatedBytes % 16 == 12)
                {
                    KeyExpansionCore(tmp, rconIter--);
                }

                uint32_t startIndex = expandedSize - generatedBytes - 4;
                for(int i = 0; i < 4; i++)
                {
                    expanded[startIndex + i] = expanded[startIndex + 16 + i] ^ tmp[i];
                }
                generatedBytes += 4;
            }

            for(int i = 0; i < AES128_ROUNDS + 1; i++)
            {
                for(int j = 0; j < AES128_BLOCK_SIZE; j++)
                {
                    expandedKey[i][j] = expanded[i * AES128_BLOCK_SIZE + j];
                }
            }
            return expandedKey;
        }

        static void SubBytes(std::array<uint8_t, AES128_BLOCK_SIZE>& state)
        {
            for(size_t i = 0; i < state.size(); ++i)
            {
                state[i] = SBox(state[i]);
            }
        }

        static void SubBytesInverse(std::array<uint8_t, AES128_BLOCK_SIZE>& state)
        {
            for(size_t i = 0; i < state.size(); ++i)
            {
                state[i] = SBoxInverse(state[i]);
            }
        }

        static void ShiftRows(std::array<uint8_t, AES128_BLOCK_SIZE>& state)
        {
            std::array<uint8_t, AES128_BLOCK_SIZE> tmp;
            for(int i = 0; i < AES128_BLOCK_SIZE; i++)
            {
                tmp[i] = state[ShiftRowIndex(i)];
            }
            state = tmp;
        }

        static uint8_t ShiftRowIndex(uint8_t byte_index)
        {
            static std::array<uint8_t, 16> shift_ind = { 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 1, 6, 11 };
            return shift_ind[byte_index];
        }

        static void ShiftRowsInverse(std::array<uint8_t, AES128_BLOCK_SIZE>& state)
        {
            std::array<uint8_t, AES128_BLOCK_SIZE> tmp;
            for(int i = 0; i < AES128_BLOCK_SIZE; i++)
            {
                tmp[i] = state[ShiftRowIndexInverse(i)];
            }
            state = tmp;
        }

        static uint8_t ShiftRowIndexInverse(uint8_t byte_index)
        {
            static std::array<uint8_t, 16> shift_ind_inv = { 0, 13, 10, 7, 4, 1, 14, 11, 8, 5, 2, 15, 12, 9, 6, 3 };
            return shift_ind_inv[byte_index];
        }

        static void MixColumns(std::array<uint8_t, AES128_BLOCK_SIZE>& state)
        {
            std::array<uint8_t, AES128_BLOCK_SIZE> tmp;

            tmp[0] = (uint8_t)(GMulByTwo(state[0]) ^ GMulByThree(state[1]) ^ state[2] ^ state[3]);
            tmp[1] = (uint8_t)(state[0] ^ GMulByTwo(state[1]) ^ GMulByThree(state[2]) ^ state[3]);
            tmp[2] = (uint8_t)(state[0] ^ state[1] ^ GMulByTwo(state[2]) ^ GMulByThree(state[3]));
            tmp[3] = (uint8_t)(GMulByThree(state[0]) ^ state[1] ^ state[2] ^ GMulByTwo(state[3]));

            tmp[4] = (uint8_t)(GMulByTwo(state[4]) ^ GMulByThree(state[5]) ^ state[6] ^ state[7]);
            tmp[5] = (uint8_t)(state[4] ^ GMulByTwo(state[5]) ^ GMulByThree(state[6]) ^ state[7]);
            tmp[6] = (uint8_t)(state[4] ^ state[5] ^ GMulByTwo(state[6]) ^ GMulByThree(state[7]));
            tmp[7] = (uint8_t)(GMulByThree(state[4]) ^ state[5] ^ state[6] ^ GMulByTwo(state[7]));

            tmp[8] = (uint8_t)(GMulByTwo(state[8]) ^ GMulByThree(state[9]) ^ state[10] ^ state[11]);
            tmp[9] = (uint8_t)(state[8] ^ GMulByTwo(state[9]) ^ GMulByThree(state[10]) ^ state[11]);
            tmp[10] = (uint8_t)(state[8] ^ state[9] ^ GMulByTwo(state[10]) ^ GMulByThree(state[11]));
            tmp[11] = (uint8_t)(GMulByThree(state[8]) ^ state[9] ^ state[10] ^ GMulByTwo(state[11]));

            tmp[12] = (uint8_t)(GMulByTwo(state[12]) ^ GMulByThree(state[13]) ^ state[14] ^ state[15]);
            tmp[13] = (uint8_t)(state[12] ^ GMulByTwo(state[13]) ^ GMulByThree(state[14]) ^ state[15]);
            tmp[14] = (uint8_t)(state[12] ^ state[13] ^ GMulByTwo(state[14]) ^ GMulByThree(state[15]));
            tmp[15] = (uint8_t)(GMulByThree(state[12]) ^ state[13] ^ state[14] ^ GMulByTwo(state[15]));

            state = tmp;
        }

        static void AddRoundKey(std::array<uint8_t, AES128_BLOCK_SIZE>& state, const std::array<uint8_t, AES128_BLOCK_SIZE>& key)
        {
            for(int i = 0; i < AES128_BLOCK_SIZE; i++)
            {
                state[i] ^= key[i];
            }
        }

    private:

        static void KeyExpansionCore(std::array<uint8_t, 4>& word, uint8_t iter)
        {
            // Rotate
            uint8_t tmp = word[0];
            word[0] = word[1];
            word[1] = word[2];
            word[2] = word[3];
            word[3] = tmp;

            // SubBytes
            for(int i = 0; i < word.size(); i++)
            {
                word[i] = SBox(word[i]);
            }

            // RCon
            word[0] ^= RCon(iter);
        }
    };

}}

#endif